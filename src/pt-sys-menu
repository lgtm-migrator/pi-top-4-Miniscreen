#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK

"""
Demonstrate being able to work with widgets.

Adapted from carousel from luma.examples by Richard Hull and contributors
"""

from demo_opts import get_device
from luma.core.virtual import viewport, snapshot, hotspot
import os
import pygame  # Used for keypress detection instead of buttons
from widgets.sys_info import batt_level, uptime, memory, disk, cpu_load, clock, hud
from widgets.main import template as main_menu
from widgets.projects import template as projects_menu
from enum import Enum


class ButtonPressHelper:
    @staticmethod
    def get():
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_a:
                    return ButtonPress(ButtonPress.ButtonType.DOWN)
                elif event.key == pygame.K_q:
                    return ButtonPress(ButtonPress.ButtonType.UP)
                elif event.key == pygame.K_p:
                    return ButtonPress(ButtonPress.ButtonType.SELECT)
                elif event.key == pygame.K_l:
                    return ButtonPress(ButtonPress.ButtonType.CANCEL)

        return ButtonPress(ButtonPress.ButtonType.NONE)


class ButtonPress:
    class ButtonType(Enum):
        NONE = 0
        UP = 1
        DOWN = 2
        SELECT = 3
        CANCEL = 4

    def __init__(self, event_type):
        self.event_type = event_type

    def is_direction(self):
        return self.event_type == self.ButtonType.DOWN or \
               self.event_type == self.ButtonType.UP

    def is_action(self):
        return self.event_type == self.ButtonType.SELECT or \
               self.event_type == self.ButtonType.CANCEL


class MenuManager:
    """Owner class for all Menus. Handles input events and controls menu behaviour."""

    def __init__(self):
        """Constructor for MenuManager"""
        self.menus = dict()
        self.menus[MenuHelper.Menus.SYS_INFO] = Menu(MenuHelper.Menus.SYS_INFO)
        self.menus[MenuHelper.Menus.MAIN_MENU] = Menu(MenuHelper.Menus.MAIN_MENU)

        self.current_menu = self.menus[MenuHelper.Menus.SYS_INFO]

    def update_state(self, button_press_type):
        if not self.current_menu.moving_to_page:
            # Check button state
            if button_press_type.event_type != ButtonPress.ButtonType.NONE:
                if button_press_type.is_direction():
                    if button_press_type.event_type == ButtonPress.ButtonType.DOWN:
                        self.current_menu.go_to_next_page()
                    elif button_press_type.event_type == ButtonPress.ButtonType.UP:
                        self.current_menu.go_to_previous_page()
                elif button_press_type.is_action():
                    if button_press_type.event_type == ButtonPress.ButtonType.SELECT:
                        current_page = self.current_menu.get_current_page()
                        self.current_menu = self.menus[current_page.select_action_menu]
                        self.current_menu.move_instantly_to_page(1)
                    elif button_press_type.event_type == ButtonPress.ButtonType.CANCEL:
                        if self.current_menu.parent is not None:
                            self.current_menu = self.menus[self.current_menu.parent]

        self.current_menu.update_position_based_on_state()

    def main_loop(self):
        try:
            while True:
                self.update_state(ButtonPressHelper.get())
        except StopIteration:
            pass


class MenuHelper:
    class Menus(Enum):
        SYS_INFO = 0
        MAIN_MENU = 1
        PROJECTS = 2
        SETTINGS = 3
        WIFI_SETUP = 4

    @staticmethod
    def add_infinite_scroll_edge_pages(pages):
        pages.insert(0, pages[-1])
        pages.append(pages[0])
        return pages

    @staticmethod
    def create_viewport(pages):
        viewport_height = sum(page.hotspot.height for page in pages) + (2 * device.height)
        virtual = viewport(device, width=device.width, height=viewport_height)

        # Start at second page, so that last entry can be added to the start for scrolling
        created_viewport_height = device.height
        for i, page in enumerate(pages):
            widget = page.hotspot
            virtual.add_hotspot(widget, (0, created_viewport_height))
            created_viewport_height += widget.height

        return virtual


class Menu:
    """A scrollable viewport of many menu MenuPageHelper.Pages.SysInfo."""

    def __init__(self, name):
        """Constructor for Menu"""
        self.pages = []
        self.move_instantly_to_page(1)
        self.moving_to_page = False
        self.name = name
        self.parent = None

        if name == MenuHelper.Menus.SYS_INFO:
            pages = MenuPageHelper.get_sys_widgets_from_config()
        elif name == MenuHelper.Menus.MAIN_MENU:
            self.parent = MenuHelper.Menus.SYS_INFO
            pages = MenuPageHelper.get_main_menu_widgets()
        else:
            raise Exception("Unrecognised menu name")

        self.pages = MenuHelper.add_infinite_scroll_edge_pages(pages)
        self.viewport = MenuHelper.create_viewport(self.pages)

    def move_instantly_to_page(self, page_index):
        self.page_index = page_index
        self.y_pos = self.page_index * device.height

    def go_to_previous_page(self):
        self.page_index = self.page_index - 1

    def go_to_next_page(self):
        self.page_index = self.page_index + 1

    def get_current_page(self):
        return self.pages[self.page_index]

    def second_to_last_page_no(self):
        return len(self.pages) - 2

    def last_page_no(self):
        return len(self.pages) - 1

    def update_position_if_at_end_of_viewport(self):
        if self.page_index == 0:
            self.move_instantly_to_page(self.second_to_last_page_no())
        elif self.page_index == self.last_page_no():
            self.move_instantly_to_page(1)

    def update_position_based_on_state(self):
        resting_pos = (self.page_index * device.height)
        arrived_at_screen = (self.y_pos == resting_pos)
        if arrived_at_screen:
            if self.moving_to_page:
                self.update_position_if_at_end_of_viewport()
        else:
            self.y_pos = self.y_pos - 1 if resting_pos < self.y_pos else self.y_pos + 1

        self.moving_to_page = not arrived_at_screen
        self.viewport.set_position((0, self.y_pos))

    def get_viewport_height(self):
        return self.viewport.size[1]


class MenuPageHelper:
    """A widget that takes up the full size of the display. Component of a menu."""

    class Pages:
        # Note - all enum values must be different!
        class SysInfo(Enum):
            # These are strings so that they can be enabled/disabled via a config file
            BATTERY = "battery"
            UPTIME = "uptime"
            MEMORY = "memory"
            DISK = "disk"
            CPU = "cpu"
            CLOCK = "clock"
            HUD = "hud"
            # NETWORK = "network"

        class MainMenu(Enum):
            PROJECT_SELECT = 0
            SETTINGS_SELECT = 1
            WIFI_SETUP_SELECT = 2

        class Template(Enum):
            PROJECT_PAGE = 3

    @staticmethod
    def get_menu_enum_class_from_name(menu_name):
        if menu_name == MenuHelper.Menus.SYS_INFO:
            return MenuPageHelper.Pages.SysInfo
        elif menu_name == MenuHelper.Menus.MAIN_MENU:
            return MenuPageHelper.Pages.MainMenu
        else:
            raise Exception("Unrecognised menu name: " + menu_name)

    @staticmethod
    def get_page_names(menu_name):
        pages_enum = MenuPageHelper.get_menu_enum_class_from_name(menu_name)
        return[page_name.value for page_id, page_name in pages_enum.__members__.items()]

    @staticmethod
    def get_page_ids(menu_name):
        pages_enum = MenuPageHelper.get_menu_enum_class_from_name(menu_name)
        return pages_enum.__members__.items()

    @staticmethod
    def get_enum_key_from_value(menu_name, value):
        pages_enum = MenuPageHelper.get_menu_enum_class_from_name(menu_name)
        for page_id, page_name in pages_enum.__members__.items():
            if page_name.value == value:
                return page_name
        raise Exception("Unable to find enum key matching value: " + str(value))

    @staticmethod
    def _get_hotspot(render_func, widget_width=128, widget_height=64, interval=0.0):
        if float(interval) == 0.0:
            return hotspot(widget_width, widget_height, render_func)
        else:
            return snapshot(widget_width, widget_height, render_func, interval=interval)

    @staticmethod
    def get_hotspot(widget_id):
        if widget_id == MenuPageHelper.Pages.SysInfo.BATTERY:
            return MenuPageHelper._get_hotspot(batt_level.render, interval=1.0)

        elif widget_id == MenuPageHelper.Pages.SysInfo.UPTIME:
            return MenuPageHelper._get_hotspot(uptime.render, interval=1.0)

        elif widget_id == MenuPageHelper.Pages.SysInfo.MEMORY:
            return MenuPageHelper._get_hotspot(memory.render, interval=2.0)

        elif widget_id == MenuPageHelper.Pages.SysInfo.DISK:
            return MenuPageHelper._get_hotspot(disk.render, interval=2.0)

        elif widget_id == MenuPageHelper.Pages.SysInfo.CPU:
            return MenuPageHelper._get_hotspot(cpu_load.render, interval=0.5)

        elif widget_id == MenuPageHelper.Pages.SysInfo.CLOCK:
            return MenuPageHelper._get_hotspot(clock.render, interval=1.0)

        elif widget_id == MenuPageHelper.Pages.SysInfo.HUD:
            return MenuPageHelper._get_hotspot(hud.render, interval=1.0)

        elif widget_id == MenuPageHelper.Pages.MainMenu.PROJECT_SELECT:
            return MenuPageHelper._get_hotspot(main_menu.page(title="Projects"), interval=0.0)

        elif widget_id == MenuPageHelper.Pages.MainMenu.SETTINGS_SELECT:
            return MenuPageHelper._get_hotspot(main_menu.page(title="Settings"), interval=0.0)

        elif widget_id == MenuPageHelper.Pages.MainMenu.WIFI_SETUP_SELECT:
            return MenuPageHelper._get_hotspot(main_menu.page(title="Wi-Fi Setup"), interval=0.0)

        elif widget_id == MenuPageHelper.Pages.Template.PROJECT_PAGE:
            return MenuPageHelper._get_hotspot(projects_menu.page(title="My Project"), interval=0.0)

        # Commented out until merged into one widget

        # elif widget_name == "network":
        #     net_wlan = get_hotspot(network.stats("wlan0"), interval=2.0, widget_height=22)
        #     net_eth = get_hotspot(network.stats("eth0"), interval=2.0, widget_height=21)
        #     net_lo = get_hotspot(network.stats("lo"), interval=2.0, widget_height=21)
        #     widgets_obj_arr.append(net_wlan)
        #     widgets_obj_arr.append(net_eth)
        #     widgets_obj_arr.append(net_lo)
        else:
            raise Exception("Not found: '" + widget_id[0] + "'")

    @staticmethod
    def remove_invalid_sys_info_widget_names(widget_name_list):
        valid_page_names = MenuPageHelper.get_page_names(MenuHelper.Menus.SYS_INFO)
        for widget_name in widget_name_list:
            if widget_name not in valid_page_names:
                widget_name_list.remove(widget_name)
        return widget_name_list

    @staticmethod
    def get_sys_widgets_from_config():
        try:
            with open(os.path.expanduser('~/.carousel'), 'r') as f:
                widget_name_arr = MenuPageHelper.remove_invalid_sys_info_widget_names(f.read().splitlines())
                # Do something if this ends up empty - show a "none selected" screen?

        except FileNotFoundError:
            # Default
            print("No config file - falling back to default")
            widget_name_arr = ['cpu', 'clock', 'disk']

        widgets_obj_arr = []

        for widget_name in widget_name_arr:
            widget_id = MenuPageHelper.get_enum_key_from_value(MenuHelper.Menus.SYS_INFO, widget_name)
            page = MenuPage(hotspot_id=widget_id, select_action_menu=MenuHelper.Menus.MAIN_MENU)
            widgets_obj_arr.append(page)

        return widgets_obj_arr

    @staticmethod
    def get_main_menu_widgets():
        widgets_obj_arr = []

        page_names = MenuPageHelper.get_page_names(MenuHelper.Menus.MAIN_MENU)
        for page_name in page_names:
            page_id = MenuPageHelper.get_enum_key_from_value(MenuHelper.Menus.MAIN_MENU, page_name)
            page = MenuPage(hotspot_id=page_id, select_action_menu=MenuHelper.Menus.PROJECTS)
            widgets_obj_arr.append(page)

        return widgets_obj_arr

class MenuPage:
    """Base view on screen"""

    def __init__(self, hotspot_id, select_action_menu):
        """Constructor for MenuPage"""
        self.select_action_menu = select_action_menu
        self.hotspot = MenuPageHelper.get_hotspot(hotspot_id)



def main():
    app = MenuManager()
    app.main_loop()


if __name__ == "__main__":
    try:
        pygame.init()
        device = get_device()
        main()
    except KeyboardInterrupt:
        pass
