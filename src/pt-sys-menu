#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK

"""
Demonstrate being able to work with widgets.

Adapted from carousel from luma.examples by Richard Hull and contributors
"""

from demo_opts import get_device
from luma.core.virtual import viewport, snapshot, hotspot
import os
import pygame  # Used for keypress detection instead of buttons
from hotspot.sys_info import batt_level, uptime, memory, disk, cpu_load, clock
from hotspot.main_menu import template as main_menu


class ButtonPress:
    NONE = 0
    UP = 1
    DOWN = 2
    SELECT = 3
    CANCEL = 4

    def __init__(self, event_type):
        self.event_type = event_type

    def is_direction(self):
        return self.event_type == self.DOWN or \
               self.event_type == self.UP

    def is_action(self):
        return self.event_type == self.SELECT or \
               self.event_type == self.CANCEL

    @staticmethod
    def get():
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_a:
                    return ButtonPress(ButtonPress.DOWN)
                elif event.key == pygame.K_q:
                    return ButtonPress(ButtonPress.UP)
                elif event.key == pygame.K_p:
                    return ButtonPress(ButtonPress.SELECT)
                elif event.key == pygame.K_l:
                    return ButtonPress(ButtonPress.CANCEL)

        # Default case:
        return ButtonPress(ButtonPress.NONE)

class MenuHandler:
    """Owner class for all menus. Handles input events and controls menu behaviour."""

    def __init__(self):
        """Constructor for MenuHandler"""
        # Create menus...
        self.menus = dict()
        self.menus["sys_info"] = Menu("sys_info")
        self.menus["main_menu"] = Menu("main_menu")

        self.current_menu = self.menus["sys_info"]

    def update_state(self, button_press_type):
        if not self.current_menu.moving_to_page:
            # Check button state
            if button_press_type.is_direction():
                if button_press_type.event_type == ButtonPress.DOWN:
                    self.current_menu.go_to_next_page()
                elif button_press_type.event_type == ButtonPress.UP:
                    self.current_menu.go_to_previous_page()
            elif button_press_type.is_action():
                if button_press_type.event_type == ButtonPress.SELECT:
                    current_page = self.current_menu.get_current_page()
                    self.current_menu = self.menus[current_page.select_action_menu]
                elif button_press_type.event_type == ButtonPress.CANCEL:
                    if self.current_menu.parent is not None:
                        self.current_menu = self.menus[self.current_menu.parent]

        self.current_menu.update_position_based_on_state()

    def main_loop(self):
        try:
            while True:
                self.update_state(ButtonPress.get())
        except StopIteration:
            pass


class MenuHelper:
    @staticmethod
    def add_infinite_scroll_edge_pages(pages):
        pages.insert(0, pages[-1])
        pages.append(pages[0])
        return pages

    @staticmethod
    def create_viewport(pages):
        viewport_height = sum(page.hotspot.height for page in pages) + (2 * device.height)
        virtual = viewport(device, width=device.width, height=viewport_height)

        # Start at second page, so that last entry can be added to the start for scrolling
        created_viewport_height = device.height
        for i, page in enumerate(pages):
            widget = page.hotspot
            virtual.add_hotspot(widget, (0, created_viewport_height))
            created_viewport_height += widget.height

        return virtual


class Menu:
    """A scrollable viewport of many menu pages."""

    def __init__(self, name):
        """Constructor for Menu"""
        self.pages = []
        self.page_index = 1
        self.y_pos = self.page_index * device.height
        self.moving_to_page = False
        self.name = name
        self.parent = None

        if name == "sys_info":
            pages = MenuPageHelper.get_sys_widgets_from_config()
        elif name == "main_menu":
            self.parent = "sys_info"
            pages = MenuPageHelper.get_main_menu_widgets()
        else:
            raise Exception("Unrecognised menu name")

        self.pages = MenuHelper.add_infinite_scroll_edge_pages(pages)
        self.viewport = MenuHelper.create_viewport(self.pages)

    def go_to_previous_page(self):
        self.page_index = self.page_index - 1

    def go_to_next_page(self):
        self.page_index = self.page_index + 1

    def get_current_page(self):
        return self.pages[self.page_index]

    def update_position_if_at_end_of_viewport(self):
        if self.page_index == 0:
            self.page_index = len(self.pages) - 1
        elif self.page_index == len(self.pages):
            self.page_index = 1
        self.y_pos = int(self.page_index * device.height)

    def update_position_based_on_state(self):
        resting_pos = (self.page_index * device.height)
        arrived_at_screen = (self.y_pos == resting_pos)
        if arrived_at_screen:
            if self.moving_to_page:
                self.update_position_if_at_end_of_viewport()
        else:
            self.y_pos = self.y_pos - 1 if resting_pos < self.y_pos else self.y_pos + 1

        self.moving_to_page = not arrived_at_screen
        self.viewport.set_position((0, self.y_pos))

    def get_viewport_height(self):
        return self.viewport.size[1]


class MenuPageHelper:
    """A widget that takes up the full size of the display. Component of a menu."""

    @staticmethod
    def _get_hotspot(render_func, widget_width=128, widget_height=64, interval=0.0):
        if float(interval) == 0.0:
            return hotspot(widget_width, widget_height, render_func)
        else:
            return snapshot(widget_width, widget_height, render_func, interval=interval)

    @staticmethod
    def get_hotspot(widget_name):
        if widget_name == "battery":
            return MenuPageHelper._get_hotspot(batt_level.render, interval=1.0)

        elif widget_name == "uptime":
            return MenuPageHelper._get_hotspot(uptime.render, interval=1.0)

        elif widget_name == "memory":
            return MenuPageHelper._get_hotspot(memory.render, interval=2.0)

        elif widget_name == "disk":
            return MenuPageHelper._get_hotspot(disk.render, interval=2.0)

        elif widget_name == "cpu":
            return MenuPageHelper._get_hotspot(cpu_load.render, interval=0.5)

        elif widget_name == "clock":
            return MenuPageHelper._get_hotspot(clock.render, interval=1.0)

        elif widget_name == "project_select":
            return MenuPageHelper._get_hotspot(main_menu.page(title="Projects"), interval=0.0)

        # Commented out until merged into one widget

        # elif widget_name == "network":
        #     net_wlan = get_hotspot(network.stats("wlan0"), interval=2.0, widget_height=22)
        #     net_eth = get_hotspot(network.stats("eth0"), interval=2.0, widget_height=21)
        #     net_lo = get_hotspot(network.stats("lo"), interval=2.0, widget_height=21)
        #     widgets_obj_arr.append(net_wlan)
        #     widgets_obj_arr.append(net_eth)
        #     widgets_obj_arr.append(net_lo)
        else:
            raise Exception("Not found: '" + widget_name + "'")

    @staticmethod
    def get_valid_widget_names():
        return ["uptime", "battery", "memory", "disk", "cpu", "clock", "network"]

    @staticmethod
    def remove_invalid_widget_names(widget_name_list):
        valid_widget_names = MenuPageHelper.get_valid_widget_names()
        for widget_name in widget_name_list:
            if widget_name not in valid_widget_names:
                widget_name_list.remove(widget_name)
        return widget_name_list

    @staticmethod
    def get_sys_widgets_from_config():
        try:
            with open(os.path.expanduser('~/.carousel'), 'r') as f:
                widget_name_arr = MenuPageHelper.remove_invalid_widget_names(f.read().splitlines())
                # Do something if this ends up empty - show a "none selected" screen?

        except FileNotFoundError:
            # Default
            print("No config file - falling back to default")
            widget_name_arr = ["cpu"]

        widgets_obj_arr = []

        for widget_name in widget_name_arr:
            page = MenuPage(hotspot_name=widget_name, select_action_menu="main_menu")
            widgets_obj_arr.append(page)

        return widgets_obj_arr

    @staticmethod
    def get_main_menu_widgets():
        widgets_obj_arr = []

        page = MenuPage(hotspot_name="project_select", select_action_menu="projects")
        widgets_obj_arr.append(page)

        return widgets_obj_arr

class MenuPage:
    """Base view on screen"""

    def __init__(self, hotspot_name, select_action_menu):
        """Constructor for MenuPage"""
        self.select_action_menu = select_action_menu
        self.hotspot = MenuPageHelper.get_hotspot(hotspot_name)  # maybe an enum is better?



def main():
    app = MenuHandler()
    app.main_loop()


if __name__ == "__main__":
    try:
        device = get_device()
        main()
    except KeyboardInterrupt:
        pass
