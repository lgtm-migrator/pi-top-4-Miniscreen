#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK

"""
Demonstrate being able to work with widgets.

Adapted from carousel from luma.examples by Richard Hull and contributors
"""

from demo_opts import get_device
from luma.core.virtual import viewport, snapshot
import os
import pygame  # Used for keypress detection instead of buttons


def get_snapshot(render_func, interval, widget_width=128, widget_height=64):
    return snapshot(widget_width, widget_height, render_func, interval=interval)


def get_valid_widget_names():
    return ["uptime", "battery", "memory", "disk", "cpu", "clock", "network"]


def remove_invalid_widget_names(widget_name_list):
    valid_widget_names = get_valid_widget_names()
    for widget_name in widget_name_list:
        if widget_name not in valid_widget_names:
            widget_name_list.remove(widget_name)
    return widget_name_list


def get_widgets_from_config():
    try:
        with open(os.path.expanduser('~/.carousel'), 'r') as f:
            widget_name_arr = remove_invalid_widget_names(f.read().splitlines())
            # Do something if this ends up empty - show a "none selected" screen?

    except FileNotFoundError as e:
        # Default
        print("No config file - falling back to default")
        widget_name_arr = ["cpu", "battery", "clock"]

    widgets_obj_arr = []

    for widget_name in widget_name_arr:
        if widget_name == "battery":
            print(widget_name)
            from hotspot import batt_level
            widgets_obj_arr.append(get_snapshot(batt_level.render, interval=1.0))

        elif widget_name == "uptime":
            print(widget_name)
            from hotspot import uptime
            widgets_obj_arr.append(get_snapshot(uptime.render, interval=1.0))

        elif widget_name == "memory":
            print(widget_name)
            from hotspot import memory
            widgets_obj_arr.append(get_snapshot(memory.render, interval=2.0))


        elif widget_name == "disk":
            from hotspot import disk
            print(widget_name)
            widgets_obj_arr.append(get_snapshot(disk.render, interval=2.0))


        elif widget_name == "cpu":
            print(widget_name)
            from hotspot import cpu_load
            widgets_obj_arr.append(get_snapshot(cpu_load.render, interval=0.5))

        elif widget_name == "clock":
            print(widget_name)
            from hotspot import clock
            widgets_obj_arr.append(get_snapshot(clock.render, interval=1.0))

        elif widget_name == "network":
            print(widget_name)
            from hotspot import network

            net_wlan = get_snapshot(network.stats("wlan0"), interval=2.0, widget_height=22)
            net_eth = get_snapshot(network.stats("eth0"), interval=2.0, widget_height=21)
            net_lo = get_snapshot(network.stats("lo"), interval=2.0, widget_height=21)
            widgets_obj_arr.append(net_wlan)
            widgets_obj_arr.append(net_eth)
            widgets_obj_arr.append(net_lo)
        else:
            print("Not found: '" + widget_name + "'")

    return widgets_obj_arr


def create_viewport(widgets, viewport_height):
    virtual = viewport(device, width=device.width, height=viewport_height)

    # Start at second page, so that last entry can be added to the start for scrolling
    created_viewport_height = device.height
    for i, widget in enumerate(widgets):
        virtual.add_hotspot(widget, (0, created_viewport_height))
        created_viewport_height += widget.height

        # Assumes that one widget = one page
        first_page = (i == 0)
        if first_page:
            virtual.add_hotspot(widget, (0, viewport_height - device.height))

        last_page = (i == (len(widgets) - 1))
        if last_page:
            virtual.add_hotspot(widget, (0, 0))

    return virtual


def process_keypresses(viewport_height):
    new_page_index = page_index
    action = None

    for event in pygame.event.get():
        if not moving and event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q or event.key == pygame.K_a:
                new_page_index = get_page_index(viewport_height, event.key)
            if event.key == pygame.K_p:
                # action = select()  # Something to do with selection
                pass
            if event.key == pygame.K_l:
                # action = cancel()  # Something to do with cancelling
                pass

    return new_page_index, action


def get_page_index(viewport_height, event_key):
    global page_index

    max_no_of_pages = (viewport_height / device.height) - 1

    if event_key == pygame.K_a:
        if page_index == max_no_of_pages:
            return 0
        else:
            return page_index + 1

    elif event_key == pygame.K_q:
        if page_index == 0:
            return max_no_of_pages
        else:
            return page_index - 1

    return page_index


def main():
    global page_index
    global y_pos
    global moving

    widgets = get_widgets_from_config()
    total_widget_len = sum(widget.height for widget in widgets)
    viewport_height = total_widget_len + (2 * device.height)  # Needed to provide seamless scrolling

    main_menu = create_viewport(widgets, viewport_height)

    try:
        while True:
            page_index, action = process_keypresses(viewport_height)

            resting_pos = (page_index * device.height)
            if y_pos == resting_pos:
                if moving:
                    moving = False

                    # Update page_index and position immediately if we are at the ends
                    max_no_of_pages = (viewport_height / device.height) - 1

                    if page_index == 0:
                        page_index = max_no_of_pages - 1

                    elif page_index == (max_no_of_pages - 1):
                        page_index = 0

                y_pos = page_index * device.height
            else:
                moving = True
                if resting_pos < y_pos:
                    y_pos = y_pos - 1
                else:
                    y_pos = y_pos + 1

            pos = (0, y_pos)
            main_menu.set_position(pos)
    except StopIteration:
        pass

if __name__ == "__main__":
    try:
        device = get_device()
        page_index = 1
        y_pos = 64
        moving = False
        main()
    except KeyboardInterrupt:
        pass
